---
description: Definitive guidelines for all files. Project-wide standards, conventions, and best practices for the Ticket a
alwaysApply: true
---
# General Best Practices

This guide outlines project-wide standards and conventions that apply across all parts of the Ticket monorepo. These principles ensure consistency, maintainability, and scalability.

## 1. Project Structure and Monorepo Organization

The Ticket project is organized as a monorepo with clear separation between backend and frontend.

**Structure:**
```
Ticket/
├── backend/          # FastAPI + LangChain agent backend
│   ├── src/
│   │   └── agent/    # Agent system with tools and middleware
│   ├── main.py       # Entry point
│   └── pyproject.toml
├── task/             # SvelteKit frontend
│   ├── src/
│   │   ├── routes/   # SvelteKit routes
│   │   └── lib/      # Shared utilities and components
│   └── package.json
└── .cursor/
    └── rules/        # Cursor rules (this file and others)
```

**Rule**: Maintain clear boundaries between backend and frontend. Backend code goes in `backend/`, frontend code goes in `task/`. Shared types or interfaces should be defined in their respective domains, not in a shared folder unless absolutely necessary.

## 2. Code Quality Standards

### Type Safety: Mandatory Everywhere

**Rule**: All code must have comprehensive type hints. This applies to both Python and TypeScript.

❌ BAD (Python):
```python
def process_data(data):
    return data["value"]
```

✅ GOOD (Python):
```python
from typing import Dict, Any

def process_data(data: Dict[str, Any]) -> str:
    return data["value"]
```

❌ BAD (TypeScript):
```typescript
function processData(data) {
  return data.value;
}
```

✅ GOOD (TypeScript):
```typescript
interface Data {
  value: string;
}

function processData(data: Data): string {
  return data.value;
}
```

### Error Handling: Explicit and Structured

**Rule**: Always handle errors explicitly. Use appropriate error types and provide meaningful error messages.

❌ BAD:
```python
def get_user(user_id):
    user = db.query(User).filter(User.id == user_id).first()
    return user  # Returns None if not found, caller must guess
```

✅ GOOD:
```python
from fastapi import HTTPException, status

def get_user(user_id: int) -> User:
    user = db.query(User).filter(User.id == user_id).first()
    if not user:
        raise HTTPException(
            status_code=status.HTTP_404_NOT_FOUND,
            detail=f"User with id {user_id} not found"
        )
    return user
```

### Naming Conventions

**Rule**: Use clear, descriptive names that indicate purpose and scope.

- **Python**: Use `snake_case` for functions, variables, and modules. Use `PascalCase` for classes. Use `UPPER_SNAKE_CASE` for constants.
- **TypeScript**: Use `camelCase` for variables and functions. Use `PascalCase` for classes, interfaces, and types. Use `UPPER_SNAKE_CASE` for constants.
- **Files**: Use `kebab-case` for file names when appropriate (e.g., `user-service.ts`), or match the language convention.

❌ BAD:
```python
def proc(d):  # Unclear what 'proc' does or what 'd' is
    return d + 1
```

✅ GOOD:
```python
def increment_counter(counter: int) -> int:
    return counter + 1
```

## 3. Documentation Standards

**Rule**: Document all public APIs, complex logic, and non-obvious decisions.

- **Python**: Use docstrings following Google or NumPy style. Include type information in docstrings if not using type hints.
- **TypeScript**: Use JSDoc comments for functions, classes, and complex logic.
- **README files**: Keep README files updated with setup instructions, architecture overview, and key decisions.

✅ GOOD (Python):
```python
def create_rag_agent(token: str) -> Agent:
    """
    Creates a RAG (Retrieval-Augmented Generation) agent with GitHub integration.
    
    Args:
        token: GitHub authentication token for API access.
        
    Returns:
        Configured agent instance with GitHub tools and middleware.
        
    Raises:
        ValueError: If token is empty or invalid format.
    """
    # Implementation
```

✅ GOOD (TypeScript):
```typescript
/**
 * Processes user input and sends it to the backend agent.
 * 
 * @param input - The user's message content
 * @param context - Optional context object with repository information
 * @returns Promise resolving to the agent's response
 * @throws {Error} If the API request fails
 */
async function sendMessage(input: string, context?: Context): Promise<string> {
  // Implementation
}
```

## 4. Environment and Configuration Management

**Rule**: Never commit secrets, API keys, or sensitive configuration. Use environment variables and `.env` files (which should be in `.gitignore`).

**Backend (Python)**:
- Use `pydantic-settings` for configuration management
- Store all secrets in environment variables
- Provide `.env.example` with placeholder values

**Frontend (TypeScript/SvelteKit)**:
- Use SvelteKit's environment variables (`$env/static/private` for server-side, `$env/static/public` for client-side)
- Never expose secrets to the client
- Use `.env.example` for documentation

❌ BAD:
```python
# Hardcoded secret
API_KEY = "sk-1234567890abcdef"
DATABASE_URL = "postgresql://user:password@localhost/db"
```

✅ GOOD:
```python
# src/core/config.py
from pydantic_settings import BaseSettings, SettingsConfigDict

class Settings(BaseSettings):
    api_key: str
    database_url: str
    
    model_config = SettingsConfigDict(env_file=".env", extra="ignore")

settings = Settings()
```

## 5. Testing Philosophy

**Rule**: Write tests for critical business logic, complex algorithms, and integration points. Prefer integration tests over unit tests for API endpoints.

**Backend**:
- Use `pytest` for Python tests
- Test agent tools, middleware, and API endpoints
- Mock external API calls (GitHub, etc.)

**Frontend**:
- Use Vitest for unit tests (co-located with code)
- Use Playwright for E2E tests in `tests/` directory
- Test user interactions and critical flows

**Rule**: Tests should be fast, isolated, and deterministic. Avoid flaky tests that depend on timing or external state.

## 6. Git Workflow and Versioning

**Rule**: Follow conventional commit messages and maintain a clean git history.

- Use descriptive commit messages: `feat: add GitHub issue creation tool`
- Prefix with type: `feat`, `fix`, `docs`, `refactor`, `test`, `chore`
- Keep commits focused and atomic
- Use branches for features (`feat/feature-name`) and fixes (`fix/bug-name`)

**Rule**: Keep the main branch deployable. All code should be tested and reviewed before merging.

## 7. Dependency Management

**Rule**: Keep dependencies up to date and minimize dependency count. Regularly audit for security vulnerabilities.

**Backend**:
- Use `uv` for Python dependency management (as indicated by `uv.lock`)
- Pin versions in `pyproject.toml` for reproducible builds
- Regularly update dependencies: `uv lock --upgrade`

**Frontend**:
- Use `npm` for Node.js dependencies
- Keep `package-lock.json` committed
- Regularly update: `npm audit fix` and `npm update`

## 8. Performance Considerations

**Rule**: Optimize for performance from the start, but avoid premature optimization.

- **Backend**: Use async/await for I/O operations. Use connection pooling for databases. Cache expensive operations when appropriate.
- **Frontend**: Lazy load components and routes. Optimize images. Minimize bundle size. Use SvelteKit's built-in optimizations (prerendering, etc.).

**Rule**: Profile before optimizing. Measure performance bottlenecks, then optimize the critical paths.

## 9. Security Best Practices

**Rule**: Security is not optional. Follow these principles:

- **Authentication**: Never trust client input. Validate and sanitize all user inputs.
- **Authorization**: Check permissions at every boundary (API endpoints, database queries).
- **Secrets**: Never log or expose secrets. Use secure storage for production secrets.
- **Dependencies**: Regularly update dependencies to patch security vulnerabilities.
- **HTTPS**: Always use HTTPS in production. Never send sensitive data over HTTP.

## 10. Code Review Standards

**Rule**: All code changes should be reviewed before merging. Reviewers should check:

- Type safety and error handling
- Test coverage for new features
- Documentation completeness
- Security implications
- Performance considerations
- Adherence to project conventions

**Rule**: Be constructive in reviews. Focus on code quality and learning, not personal criticism.

## 11. Common Patterns and Conventions

### Domain-Driven Design (Backend)

**Rule**: Organize backend code by domain/feature, not by technical layer.

✅ GOOD:
```
backend/src/
├── agent/
│   ├── agent.py
│   └── tools/
│       └── github/
│           ├── main.py
│           ├── issues.py
│           └── comments.py
```

❌ BAD:
```
backend/src/
├── routers/
├── models/
├── services/
└── schemas/
```

### Component Composition (Frontend)

**Rule**: Build small, reusable components. Compose complex UIs from simple building blocks.

✅ GOOD:
```svelte
<!-- Small, focused component -->
<script lang="ts">
  interface Props {
    label: string;
    value: string;
  }
  let { label, value }: Props = $props();
</script>

<div class="field">
  <label>{label}</label>
  <span>{value}</span>
</div>
```

## 12. Logging and Observability

**Rule**: Use structured logging for better observability and debugging.

**Backend**:
- Use Python's `logging` module with structured formatters (JSON when possible)
- Log to stdout/stderr (let deployment handle aggregation)
- Include context in logs (request IDs, user IDs, etc.)

**Frontend**:
- Use console logging sparingly (remove in production)
- Consider structured logging libraries for complex applications
- Log errors with context for debugging

## 13. Migration and Backwards Compatibility

**Rule**: When making breaking changes, provide migration paths and document changes clearly.

- Use versioning for APIs (`/v1/`, `/v2/`)
- Deprecate old APIs before removing them
- Provide clear migration guides
- Maintain backwards compatibility when possible

## 14. Accessibility and Inclusivity

**Rule**: Build accessible applications that work for all users.

- Use semantic HTML
- Ensure keyboard navigation works
- Provide ARIA labels where needed
- Test with screen readers
- Ensure sufficient color contrast
- Support multiple languages when applicable

## 15. Continuous Improvement

**Rule**: Regularly refactor and improve code quality. Technical debt should be tracked and addressed.

- Refactor when you see opportunities for improvement
- Remove dead code and unused dependencies
- Update documentation as code evolves
- Learn from bugs and incidents
- Share knowledge with the team

---

**Remember**: These guidelines are living documents. As the project evolves, update these rules to reflect new patterns, technologies, and learnings. When in doubt, prioritize clarity, maintainability, and user experience.
